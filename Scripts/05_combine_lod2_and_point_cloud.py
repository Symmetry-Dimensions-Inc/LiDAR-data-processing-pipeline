import os
import copy
import math
import numpy as np
import open3d as o3d
import trimesh
import laspy
import matplotlib.pyplot as plt
import time


"""
Compare a building LiDAR point cloud to a point cloud generated from a LOD2 model of the same building, and attempt to cover any holes in the LiDAR scan with the LOD2 data,
in order to create a point cloud that is easier to turn into a mesh of correct shape.
The resulting point cloud is outputted into a new LAS file, but if the flags are set, Poisson Surface Reconstruction algorithm can also be used to turn it directly into a mesh, which
in turn can be used to detect and output window positions on the building surface.
It should be noted that the Poisson Surface Reconstruction algorithm requires the input point cloud to have correctly set normal vectors in order to create an accurate mesh. 
This is generally not feasable for many buildings due to complex shapes and things like building's internal structures visible in the point cloud, so for mesh generation,
it is better to use a different algorithm, iPSR, which can be invoked using the 'run_iPSR.py' script.
"""


use_preprocessed_data         = False # If True, load point clouds from file and move directly into mesh generation. Has some issues now, so better not to use.
create_meshes                 = True  # If True, use Poisson Surface Reconstruction algorithm to generate a mesh for the combined data. (Better to use iPSR with 'run_iPSR.py')
filter_low_density_from_mesh  = False # If True, the output Poisson mesh will have holes in places, where not enough points are available.
skip_lod2_on_mesh_creation    = False # If True, mesh is created using only LiDAR data (generally results in very bad meshes)
perform_window_detection      = True  # Requires 'create_meshes' to be set to True

### Input/Output files and folders ###
input_point_cloud_path        = "S:/OSS/Data/Aligned_point_clouds/"
input_lod2_obj_path           = "S:/OSS/Data/LOD2/"
output_point_cloud_path       = "S:/OSS/Data/Combined_point_clouds/"
output_mesh_path              = "S:/OSS/Data/Meshes/"

# Process single file
process_entire_directory      = False # If False, only a single building, defined below, will be processed from the input paths
building_number               = 349
input_point_cloud_filename    = "aligned_building_"  + str(building_number) + "_points.las"
input_lod2_obj_filename       = "building_"          + str(building_number) + ".obj"
combined_point_cloud_filename = "combined_building_" + str(building_number) + "_points.las" 
output_mesh_filename          = "Poisson_mesh_"      + str(building_number) + ".ply"


### Parameters for combining LiDAR and LOD2 data, and generating the Poisson mesh ###
# NOTE: The poisson mesh generated here is mainly for window detection purposes. The mesh generated by iPSR algorihm is of much higher quality

voxel_size                           = 0.1   # In meters. Smaller voxel sizes will increase processing time considerably
voxel_size_bottom                    = 0.2
ground_level_height_threshold        = 0.1   # To separate LOD2 bottom side points from the rest, and to erase bottom points from the LiDAR data.
street_level_height_threshold        = 8.0   # Pedestrian level which usually differs the most from LOD2 model.
high_level_height_threshold          = 50.0  # Level at which the LiDAR data is starting to become sparse and unreliable.
distance_squared_threshold_2D_points = 1.0   # Use lowest X meters of LiDAR data collapsed to a 2D plane to find LOD2 bottom points with no LiDAR data immediately above them.
distance_threshold_street_level      = 5     # On street level, don't use LOD2 data unless there is no other option. NOTE: this can be lowered, when ground level building points are recovered
distance_threshold_high_level        = 1.3   # Above street level, use LOD2 data whenever there is a hole in the LiDAR data.
normal_estimation_radius             = 1.0
mesh_creation_depth                  = 10
mesh_creation_n_threads              = 8
max_distance_from_lod2               = 6.0 # Points further than this from any LOD2 point will be erased.


### Window detection parameters ###
# NOTE: These parameters are *very* case by case. The algorithm also does not correctly detect, e.g., very wide windows.

"""
# High-quality scan of Kitakawa Clinic
density_threshold                                                    = 0.2
window_detection_use_radius_search                                   = True # Radius search bugs out at some cases, only outputting points from a portion of the input mesh
window_detection_large_low_density_area_threshold                    = 0.15
window_detection_window_maximum_size                                 = 2.0
window_detection_density_minimum_distance_to_lod2_areas              = 0.5
window_detection_density_minimum_distance_to_large_low_density_areas = 0.5
window_detection_density_cluster_together_distance                   = 0.5
window_detection_shape_depth                                         = 0.17
window_detection_shape_width                                         = 2.0
window_detection_shape_cluster_together_distance                     = 1.5
window_detection_shape_minimum_distance_to_lod2_vertical_edges       = 0.5
window_detection_shape_minimum_distance_to_lod2_areas                = 1.0
window_detection_shape_minimum_distance_to_large_low_density_areas   = 1.0
"""

# MMS scan of Hotel Central Sendai
density_threshold                                                    = 0.3
window_detection_use_radius_search                                   = False 
window_detection_large_low_density_area_threshold                    = 0.1
window_detection_window_maximum_size                                 = 2.0
window_detection_density_minimum_distance_to_lod2_areas              = 1.0
window_detection_density_minimum_distance_to_large_low_density_areas = 1.0
window_detection_density_cluster_together_distance                   = 1.5
window_detection_shape_depth                                         = 0.2
window_detection_shape_width                                         = 2.0
window_detection_shape_cluster_together_distance                     = 1.5
window_detection_shape_minimum_distance_to_lod2_vertical_edges       = 1.0
window_detection_shape_minimum_distance_to_lod2_areas                = 1.5
window_detection_shape_minimum_distance_to_large_low_density_areas   = 1.5



def convert_obj_to_point_cloud(input_file):
    """
    Use Trimesh library to read the .obj mesh and sample its surface to create a point cloud presentation.
    
    Parameters
    ----------
    input_file : string
        Full path and filename for the input .obj file
    
    Returns
    -------
    downsampled_point_cloud : Open3D point cloud
        Point cloud sampled from the input object, downsampled into a reasonable resolution
    open3d_mesh : Open3d triangle mesh
        The input object, converted into Open3D mesh format
    """
    mesh = trimesh.load( input_file, process=False, force="mesh", skip_materials=True, skip_texture=True )
    open3d_mesh = mesh.as_open3d
    samples, fid  = mesh.sample(1048576, return_index=True) # 'return_index == True' is needed for the normal vectors
    print("  Computing barycentric coordinates...")
    bary = trimesh.triangles.points_to_barycentric(triangles=mesh.triangles[fid], points=samples)
    print("  Interpolating normals...")
    interp = trimesh.unitize( (mesh.vertex_normals[mesh.faces[fid]] * trimesh.unitize(bary).reshape((-1, 3, 1))).sum(axis=1) )
    print("  Downsampling...")
    point_cloud = o3d.geometry.PointCloud()
    point_cloud.points = o3d.utility.Vector3dVector( samples )
    point_cloud.normals = o3d.utility.Vector3dVector( interp )
    downsampled_point_cloud = o3d.geometry.PointCloud.voxel_down_sample(point_cloud, voxel_size)
    
    return downsampled_point_cloud, open3d_mesh


def load_point_cloud(input_file):
    """
    Read a point cloud from either a PLY or LAS file, and downsample it.
    
    Parameters
    ----------
    input_file : string
        Full path and filename for the input point cloud
    
    Returns
    -------
    downsampled_point_cloud : Open3D point cloud
        Downsampled version of the point cloud
    """
    downsampled_point_cloud = None
    if input_file.endswith(".ply"):
        point_cloud = o3d.io.read_point_cloud(input_file)
        downsampled_point_cloud = o3d.geometry.PointCloud.voxel_down_sample(point_cloud, voxel_size)
        o3d.geometry.PointCloud.estimate_normals( downsampled_point_cloud, o3d.geometry.KDTreeSearchParamHybrid(radius=normal_estimation_radius, max_nn=30))
    elif input_file.endswith(".las"):
        las = laspy.read(input_file)
        xyz = np.vstack([las.x, las.y, las.z]).transpose()
        point_cloud = o3d.geometry.PointCloud()
        point_cloud.points = o3d.utility.Vector3dVector(xyz)
        downsampled_point_cloud = o3d.geometry.PointCloud.voxel_down_sample(point_cloud, voxel_size)
        o3d.geometry.PointCloud.estimate_normals( downsampled_point_cloud, o3d.geometry.KDTreeSearchParamHybrid(radius=normal_estimation_radius, max_nn=30))
    return downsampled_point_cloud


def filter_noise(point_cloud, min_dist, min_points, visualize_result=False):
    """
    Process the input point cloud, filtering out points that are too far away from other points.
    
    Parameters
    ----------
    point_cloud : Open3d point cloud
        Point cloud to be filtered
    min_dist : float
        Distance in which 'min_points' neighbors must be found in order to keep a point
    min_points : int
        Minimum points that have to be found within 'min_dist' of a point to not erase it.
    visualize_result : bool, optional
        If 'True', render the filtered point cloud
        
    Returns
    -------
    point_cloud : Open3D point cloud
        Filtered point cloud.
    """
    if len(point_cloud.points) == 0:
        return point_cloud
    cl, ind = point_cloud.remove_radius_outlier(nb_points=min_points, radius=min_dist) # Require 'nb_points' neighbors at 'radius' range for a point to be kept
    point_cloud = point_cloud.select_by_index(ind)
    if visualize_result == True:
        o3d.visualization.draw_geometries( [point_cloud] )    
    return point_cloud


def filter_point_clusters(point_cloud, eps = 1.0, min_points = 24, erase_all_small_clusters=False, small_cluster_threshold=200, visualize_result=False):
    """
    Process the input point cloud, filtering out point clusters that are too far away from other data.
    
    Parameters
    ----------
    point_cloud : Open3d point cloud
        Point cloud to be filtered
    eps : float
        Density parameters used for finding neighboring points
    min_points : int
        Minimum points needed to form a cluster. Any points that can't be matched to meet this threshold are erased
    erase_all_small_clusters : bool, optional
        If set to 'True', the parameter 'small_cluster_threshold' can be used to further erase too small clusters.
    small_cluster_threshold : int, optional
        Minimum cluster size to keep
    visualize_result : bool, optional
        If 'True', render the filtered point cloud
        
    Returns
    -------
    point_cloud : Open3D point cloud
        Filtered point cloud.
    """
    if len(point_cloud.points) == 0:
        return point_cloud
    points = np.asarray(point_cloud.points)
    normals = np.asarray(point_cloud.normals)
    labels = np.array( point_cloud.cluster_dbscan(eps=eps, min_points=min_points , print_progress=True) )
    max_label = labels.max()
    print(f"  point cloud has {max_label + 1} clusters")
    if erase_all_small_clusters == True:
        for i in range(max_label+1):
            count = np.count_nonzero(labels == i)
            print(f"    found {count} points in cluster {i}, total points remaining: {len(points)}")
            if count < small_cluster_threshold:
                points = points[labels != i]
                normals = normals[labels != i]
                labels = labels[labels != i]
    points = points[labels != -1] # Always erase clusters that had less than 'min_points' points in them
    normals = normals[labels != -1]
    point_cloud.points = o3d.utility.Vector3dVector(points)
    point_cloud.normals = o3d.utility.Vector3dVector(normals)
    if visualize_result == True:
        colors = plt.get_cmap("tab20")(labels / (max_label if max_label > 0 else 1))
        colors[labels < 0] = 0
        point_cloud.colors = o3d.utility.Vector3dVector(colors[:, :3])
        o3d.visualization.draw_geometries( [point_cloud] )
    return point_cloud


def filter_point_clouds( lod2_point_cloud, lidar_point_cloud, visualize_result=False ):
    """
    Combine LiDAR point cloud (generally a combination of multiple scans overlaid and aligned by script 'split_dataset_points_to_buildings_with_realignment.py') with LOD2 data.
    The target is to create a point cloud which can be easily converted into a mesh that recreates the building's shape.
    
    Parameters
    ----------
    lod2_point_cloud : Open3d point cloud
        Point cloud created from LOD2 obj file. Downsampled to some reasonable resolution.
    lidar_point_cloud : Open3d point cloud
        LiDAR point cloud, downsampled to same resolution with the LOD2 point cloud. Processing without downsampling would take a really long time.
    visualize_result : bool, optional
        If 'True', render results.
        
    Returns
    -------
    filtered_lod2_point_cloud : Open3D point cloud
        Points used in the final combined point cloud that originate from the LOD2 data.
    filtered_lidar_point_cloud : Open3D point cloud
        Points used in the final combined point cloud that originate from the LiDAR data.
    """
    filtered_lidar_point_cloud = None
    filtered_lod2_point_cloud = None
    filtered_lod2_points = []
    filtered_lod2_normals = []
    lod2_ground_level_points = [] # The bottom part of the LOD2 point cloud representing the bird's eye view footprint of the building (often minus things like balconies)
    lod2_ground_level_normals = []
    points_to_project_to_plane = [] # Gather LiDAR and LOD2 points from the lower portions of the building. They will be used to select accepted bottom face LOD2 points. (approach #2)
    normals_to_project_to_plane = []
   
    #########################
    # PREPROCESS LIDAR DATA #
    #########################
    # Erase ground level LiDAR points
    bbox = o3d.geometry.AxisAlignedBoundingBox.create_from_points(lod2_point_cloud.points)
    lod2_min_z =  bbox.min_bound[2]
    lod2_max_z = bbox.max_bound[2]
    height_threshold_ground_level = lod2_min_z + ground_level_height_threshold
    height_threshold_street_level = lod2_min_z + street_level_height_threshold
    height_threshold_high_level   = lod2_min_z + high_level_height_threshold
    height_threshold_squeeze_to_2D = (lod2_max_z-lod2_min_z)/8.0
    if height_threshold_squeeze_to_2D < street_level_height_threshold:
        height_threshold_squeeze_to_2D = street_level_height_threshold
    height_threshold_squeeze_to_2D = lod2_min_z + height_threshold_squeeze_to_2D

    lidar_points = np.asarray(lidar_point_cloud.points)
    lidar_normals = np.asarray(lidar_point_cloud.normals)
    tmp_points = []
    tmp_normals = []
    for i in range(len(lidar_points)):
        point = lidar_points[i]
        normal = lidar_normals[i]
        if point[2] > height_threshold_ground_level+0.2:
            tmp_points.append(point)
            tmp_normals.append(normal)
    lidar_points = np.asarray(tmp_points)
    lidar_normals = np.asarray(tmp_normals)
    filtered_lidar_point_cloud = o3d.geometry.PointCloud()
    filtered_lidar_point_cloud.points = o3d.utility.Vector3dVector(lidar_points)
    filtered_lidar_point_cloud.normals = o3d.utility.Vector3dVector(lidar_normals)
    
    ######################
    # SET NORMAL VECTORS #
    ######################
    # LOD2 point cloud has correctly set normal vectors. Copy them to the lidar point cloud, selecting the closest points.
    # Also, if the LiDAR point is a lot higher than the LOD2 point, there is a high probability that the LiDAR point actually belongs to the neighbor building.
    # NOTE: This filters away also things like large signboards or antennas on rooftops, since they don't show on the LOD2 data. But, this is required because of ghost points inside buildings due to reflections.
    if visualize_result == True:
        print("lod2 normals")
        o3d.visualization.draw_geometries( [lod2_point_cloud] )
    
    lod2_kd_tree = o3d.geometry.KDTreeFlann(lod2_point_cloud)
    lidar_points = np.asarray(filtered_lidar_point_cloud.points)
    points = []
    normals = []
    for i in range(len(lidar_points)):
        lidar_point = lidar_points[i]
        [k, idx, _] = lod2_kd_tree.search_knn_vector_3d(lidar_point, 1)
        nearest_point = np.asarray(lod2_point_cloud.points)[idx][0]
        if lidar_point[2] > lod2_max_z + 0.6:
            # Erase the LiDAR point if its considerably higher than highest LOD2 point .
            # This gets rid of a lot of neighbor building points and such, but also wrecks details like billboards and antennas on the roof.
            continue
        distance = np.sqrt( (lidar_point[0]-nearest_point[0])**2 + (lidar_point[1]-nearest_point[1])**2 + (lidar_point[2]-nearest_point[2])**2 )
        if distance > max_distance_from_lod2:
            # There is a bug somewhere in the pipeline, sometimes causing points from buildings far away to be included in the target building's point cloud
            continue
        points.append(lidar_point)
        nearest_point_normal = np.asarray(lod2_point_cloud.normals)[idx][0]
        normals.append(nearest_point_normal)        
    points = np.asarray(points)
    normals = np.asarray(normals)
    #print("resulting points:", points.shape)
    #print("resulting normals:", normals.shape)
    filtered_lidar_point_cloud.points = o3d.utility.Vector3dVector( points )
    filtered_lidar_point_cloud.normals = o3d.utility.Vector3dVector( normals )
    o3d.geometry.PointCloud.estimate_normals( filtered_lidar_point_cloud, o3d.geometry.KDTreeSearchParamHybrid(radius=normal_estimation_radius, max_nn=30))
    if visualize_result == True:
        print("  lidar normals")
        o3d.visualization.draw_geometries([filtered_lidar_point_cloud])

    ############################
    # FILTER LIDAR POINT CLOUD #
    ############################
    
    # Perform some nearest neighbor filtering to get rid of clear outliers
    filtered_lidar_point_cloud = filter_noise(filtered_lidar_point_cloud, 1.0, 12)
    #cl, ind = filtered_lidar_point_cloud.remove_radius_outlier(nb_points=12, radius=1.0) # Require 'nb_points' neighbors at 'radius' range for a point to be kept
    #filtered_lidar_point_cloud = filtered_lidar_point_cloud.select_by_index(ind)
        
    # Cluster the LiDAR point cloud and get rid of small, loose parts that are difficult to reconstruct into meaningful details
    filtered_lidar_point_cloud = filter_point_clusters(filtered_lidar_point_cloud, 1.0, 24)
    lidar_kd_tree_exists = False
    if len(filtered_lidar_point_cloud.points) > 0:
        lidar_kd_tree = o3d.geometry.KDTreeFlann(filtered_lidar_point_cloud)
        lidar_kd_tree_exists = True
    lidar_points = np.asarray(filtered_lidar_point_cloud.points)
    lidar_normals = np.asarray(filtered_lidar_point_cloud.normals)

    # Copy the lowest X meters of LiDAR points into a separate point cloud, which is used for LOD2 bottom point selection after 2D projection
    # NOTE: Keeping even the LiDAR ground points in the 2D projection would be nice for erasing LOD2 points under eaves, but floor points scanned through windows create problems.
    # NOTE: The three channels are added explicitely instead of just using "point" to avoid using references, which would get the original data modified as well.
    for i in range(len(lidar_points)):
        point = lidar_points[i]
        normal = lidar_normals[i]
        if point[2] > height_threshold_ground_level+0.5 and point[2] < height_threshold_squeeze_to_2D:
            points_to_project_to_plane.append([point[0], point[1], point[2]])
            normals_to_project_to_plane.append([normal[0], normal[1], normal[2]])
    

    ###########################
    # FILTER LOD2 POINT CLOUD #
    ###########################
    
    # LOD2 points are used where LiDAR data is not available    
    lod2_points = np.asarray(lod2_point_cloud.points)
    lod2_normals = np.asarray(lod2_point_cloud.normals)
    bounding_box_extents = np.empty((3,1))
    bounding_box_extents[0] = 8.0
    bounding_box_extents[1] = 1.0
    bounding_box_extents[2] = 1.0
    for i in range(len(lod2_points)):
        point = lod2_points[i]
        normal = lod2_normals[i]
        if point[2] < height_threshold_ground_level:
            # Downward face of the LOD2 model. These bottom LOD2 points go into a separate list for later processing.
            lod2_ground_level_points.append(point)       
            lod2_ground_level_normals.append(normal)
        elif point[2] < height_threshold_street_level:
            # Street level points. This is where most of the building's complex geometry is located, as well as generally the most LiDAR data.
            # NOTE: This first part clears out overhangs at street level, but leaves out parts of wall (where LOD2 is needed) that have nearby other data, including internal points seen through windows.
            dist = 9999.0
            if lidar_kd_tree_exists == True:
                [k, idx, _] = lidar_kd_tree.search_knn_vector_3d(point, 1)
                nearest_point = np.asarray(filtered_lidar_point_cloud.points)[idx][0]
                dist = np.sqrt( (point[0]-nearest_point[0])**2 + (point[1]-nearest_point[1])**2 + (point[2]-nearest_point[2])**2 )
            if dist > distance_threshold_street_level:
                filtered_lod2_points.append(point)
                filtered_lod2_normals.append(normal)
            else:
                # Need to check disgarded points again                
                # NOTE: This will cause all open doorways and other faces with nothing behind them to be blocked off by LOD2 data. Need to filter out separate small clusters to get around
                # Create a long cuboid along the LOD2 point normal vector, and see if it contains any LiDAR points. If not, accept the LOD2 point.
                # NOTE: Open3D's Python implementation of bounding box computation is broken. It will always create a 2D plane instead of a cuboid, so the Z-axis needs to be set manually.
                if normal[0] == 0:
                    angle_xy = 0
                else:
                    angle_xy = math.tan( (normal[1] / normal[0]) )
                sin_a = math.sin(angle_xy)
                cos_a = math.cos(angle_xy)
                rotation_matrix = [[cos_a, -sin_a, 0.0],
                                   [sin_a,  cos_a, 0.0],
                                   [  0.0,    0.0, 0.0]]
                OBBox = o3d.geometry.OrientedBoundingBox(point, rotation_matrix, bounding_box_extents)
                box_corners = np.asarray(OBBox.get_box_points())
                box_corners[0][2] -= 0.5
                box_corners[1][2] -= 0.5
                box_corners[2][2] -= 0.5
                box_corners[3][2] -= 0.5
                box_corners[4][2] += 0.5
                box_corners[5][2] += 0.5
                box_corners[6][2] += 0.5
                box_corners[7][2] += 0.5
                new_points = o3d.utility.Vector3dVector(box_corners)
                OBBox2 = o3d.geometry.OrientedBoundingBox.create_from_points(new_points)
                cropped_point_cloud = filtered_lidar_point_cloud.crop(OBBox2)
                if cropped_point_cloud.has_points() == False:
                    filtered_lod2_points.append(point)
                    filtered_lod2_normals.append(normal)
                #o3d.visualization.draw_geometries([OBBox, OBBox2, cropped_point_cloud, lod2_point_cloud]) 
        elif point[2] < height_threshold_high_level:
            # LOD2 points above street level are included more easily.
            dist = 9999.0
            if lidar_kd_tree_exists == True:
                [k, idx, _] = lidar_kd_tree.search_knn_vector_3d(point, 1)
                nearest_point = np.asarray(filtered_lidar_point_cloud.points)[idx][0]
                dist = np.sqrt( (point[0]-nearest_point[0])**2 + (point[1]-nearest_point[1])**2 + (point[2]-nearest_point[2])**2 )
            if abs(normal[2]) > 0.1:
                # If the Z-element of the normal vector has a large vertical element (roof), use a very small distance threshold to avoid rounded roof edges in the mesh
                if dist > distance_threshold_high_level/3:
                    filtered_lod2_points.append(point)
                    filtered_lod2_normals.append(normal)
            else:
                # Normal situation (walls, etc.), where unmodified threshold can be used
                if dist > distance_threshold_high_level:
                    filtered_lod2_points.append(point)
                    filtered_lod2_normals.append(normal)
        else:
            # Point is so high up that the LiDAR scans can be sparse/nonexisting. Automatically accept the LOD2 point.
            filtered_lod2_points.append(point)
            filtered_lod2_normals.append(normal)
    
    # Also add the lower LOD2 points to the collection of lower points to be projected into 2D for bottom face filtering
    # NOTE: It might be of interest to also consider the normal vectors here, e.g. to emphasize vertical or horizontal surfaces.
    for i in range(len(filtered_lod2_points)):
        point = filtered_lod2_points[i]
        normal = filtered_lod2_normals[i]
        if point[2] > height_threshold_ground_level+1.5 and point[2] < height_threshold_squeeze_to_2D:
            points_to_project_to_plane.append([point[0], point[1], point[2]])
            normals_to_project_to_plane.append([normal[0], normal[1], normal[2]])
    
    #############################
    # CHOOSE LOD2 BOTTOM POINTS #
    #############################
   
    # Project the lower points into a single plane. Downsample the result to get rid of overlapping points.
    for i in range(len(points_to_project_to_plane)):
        points_to_project_to_plane[i][2] = 0.0
    point_cloud_2D = o3d.geometry.PointCloud()
    point_cloud_2D.points = o3d.utility.Vector3dVector(points_to_project_to_plane)
    point_cloud_2D.normals = o3d.utility.Vector3dVector(normals_to_project_to_plane)
    point_cloud_2D = o3d.geometry.PointCloud.voxel_down_sample(point_cloud_2D, voxel_size)
    point_cloud_2D = filter_point_clusters(point_cloud_2D, 1.1, 32, True, 128   )
    #o3d.io.write_point_cloud("./Data/mesh_creation_test_data/test/test.ply", point_cloud_2D, write_ascii=False, compressed=False, print_progress=True)
    projected_bottom_points = np.asarray( point_cloud_2D.points )
    projected_bottom_points = projected_bottom_points[:,:2] # Get rid of the height component
    print("  Number of lower points projected to 2D:", len(projected_bottom_points))

    # Calculate the X/Y distance from each bottom point to the lower LiDAR points, choosing the points that are sufficiently far away from walls and overhangs (no other points directly above)
    # Downsample the LOD2 bottom points first, since otherwise this takes too long
    lod2_bottom_point_cloud = o3d.geometry.PointCloud()
    lod2_bottom_point_cloud.points = o3d.utility.Vector3dVector(lod2_ground_level_points)
    lod2_bottom_point_cloud.normals = o3d.utility.Vector3dVector(lod2_ground_level_normals)
    chosen_ground_points = []
    chosen_ground_normals = []
    print("  Bottom face LOD2 points to filter: %d" % (len(lod2_ground_level_points)) )
    for i in range(len(lod2_ground_level_points)):
        #print("Processing ground point %d/%d" % (i, len(lod2_ground_level_points)) )
        point1 = lod2_ground_level_points[i]
        normal1 = lod2_ground_level_normals[i]
        x1 = point1[0]
        y1 = point1[1]
        point_is_acceptable = True
        for j in range(len(projected_bottom_points)):
            point2 = projected_bottom_points[j]
            x2 = point2[0]
            y2 = point2[1]
            #dist = np.sqrt( (x2-x1)**2 + (y2-y1)**2 )
            dist = (x2-x1)**2 + (y2-y1)**2
            if dist < distance_squared_threshold_2D_points:
                point_is_acceptable = False
                break
        if point_is_acceptable == True:
            chosen_ground_points.append(point1)
            chosen_ground_normals.append(normal1)
            
    # Combine the filtered LOD2 point cloud upper parts with the chosen bottom points, and filter out small clusters
    #print("shape1:",np.asarray(filtered_lod2_points).shape)
    #print("shape2:",np.asarray(chosen_ground_points).shape)
    if chosen_ground_points:
        filtered_lod2_points = np.concatenate((filtered_lod2_points, chosen_ground_points), axis=0)    
        filtered_lod2_normals = np.concatenate((filtered_lod2_normals, chosen_ground_normals), axis=0)    
    filtered_lod2_point_cloud = o3d.geometry.PointCloud()
    filtered_lod2_point_cloud.points = o3d.utility.Vector3dVector(filtered_lod2_points)
    filtered_lod2_point_cloud.normals = o3d.utility.Vector3dVector(filtered_lod2_normals)
    filtered_lod2_point_cloud = filter_point_clusters(filtered_lod2_point_cloud, 1.0, 32, True, 240)    
    
    return filtered_lod2_point_cloud, filtered_lidar_point_cloud


def perform_poisson_surface_reconstruction(pcd, depth, n_threads):
    """
    Use Open3D library's implementation of Poisson Surface Reconstruction algorihm to create a watertight mesh of the input point cloud
    
    Parameters
    ----------
    pcd : Open3D point cloud
        Input point cloud to be turned into a mesh
    depth : int
        Depth of the octree used by the Poisson algorithm. Higher numbers result in higher quality, but also take longer. Above '12' the additional details are generally not worth the trouble.
    n_threads : int
        How many threads should the algorithm run in to decrease processing time.
    
    Returns
    -------
    mesh : Open3D triangle mesh
        Resulting Poisson mesh
    densities : Numpy.array
        Local point densities for each vertex in the output mesh. Can be used for example to filter out parts of the mesh that don't contain any actual data.
    """
    mesh, densities = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson( pcd, depth=depth, width=0, scale=3.0, linear_fit=True, n_threads=n_threads )
    mesh.compute_vertex_normals()
    
    return mesh, densities


def process_mesh(mesh, densities, filtered_lod2_point_cloud, complete_lod2_point_cloud, complete_lod2_mesh):
    """
    Post-processing on the generated Poisson mesh. This function will also run window detection algorithms on the mesh, if the functionality is enabled.
    
    Parameters
    ----------
    mesh : Open3D TriangleMesh
        Mesh generated by Poisson surface reconstruction algorithm.
    densities : Array of density values the size of the mesh
        Contains local point density value for each vertex in the input mesh.
    min_density : float
        Threshold for parsing low-density areas from the mesh. Used for detecting windows, which reflect light and appear as holes in the mesh after certain height
    filtered_lod2_point_cloud : Open3D point cloud
        Parts of the combined_point_cloud which originate from LOD2 data. Used by the window detection algorithm.
    complete_lod2_point_cloud : Open3D point cloud
        The entire point cloud created from the LOD2 obj file. Used for determining overall wall orientation in any location. Used by the window detection algorithm.

    Returns
    -------
    mesh_full : Open3D TriangleMesh
        Poisson mesh of the building.
    windows_mesh : Open3D TriangleMesh
        Detected windows combined into a single mesh of multiple cube objects.

    """
    
    # Remove small separate parts from the mesh
    print("   clustering connected triangles (1st iteration)...")
    triangle_clusters, cluster_n_triangles, cluster_area = ( mesh.cluster_connected_triangles() )
    triangle_clusters = np.asarray(triangle_clusters)
    cluster_n_triangles = np.asarray(cluster_n_triangles)
    cluster_area = np.asarray(cluster_area)
    print("  removing small separate components from the full mesh...")
    mesh_full = copy.deepcopy(mesh)
    triangles_to_remove = cluster_n_triangles[triangle_clusters] < 1000
    mesh_full.remove_triangles_by_mask(triangles_to_remove)
    print("    original triangle count: %d, new triangle count: %d" % (len(mesh.triangles), len(mesh_full.triangles)) )
    
    # Taubin smoothing keeps the shape of the mesh intact
    mesh_full.compute_vertex_normals()
    mesh_full = mesh_full.filter_smooth_taubin(number_of_iterations=10, lambda_filter=0.8, mu=-0.85)
    mesh_full.compute_vertex_normals()
    mesh_full.paint_uniform_color([1, 0.706, 0])
    
    # Color-coded density mesh for visualization (identical other than coloring)
    densities = np.asarray(densities)    
    density_colors = plt.get_cmap("jet")(
        (densities - densities.min()) / (densities.max() - densities.min())
    )
    density_colors = density_colors[:, :3]
    density_mesh = o3d.geometry.TriangleMesh()
    density_mesh.vertices = mesh.vertices
    density_mesh.triangles = mesh.triangles
    density_mesh.triangle_normals = mesh.triangle_normals
    density_mesh.vertex_colors = o3d.utility.Vector3dVector(density_colors)

    # Create the output mesh
    mesh_filtered = copy.deepcopy(density_mesh)
    if filter_low_density_from_mesh == True:
        vertices_to_remove = densities < np.quantile( densities, (density_threshold/2.0) )
        mesh_filtered.remove_vertices_by_mask(vertices_to_remove)
        mesh_filtered = mesh_filtered.remove_duplicated_vertices()
        mesh_filtered = mesh_filtered.remove_duplicated_triangles()
        mesh_filtered = mesh_filtered.remove_degenerate_triangles()
        triangle_clusters, cluster_n_triangles, cluster_area = ( mesh_filtered.cluster_connected_triangles() )
        triangle_clusters = np.asarray(triangle_clusters)
        cluster_n_triangles = np.asarray(cluster_n_triangles)
        triangles_to_remove = cluster_n_triangles[triangle_clusters] < 100
        mesh_filtered.remove_triangles_by_mask(triangles_to_remove)
            
    # WINDOW DETECTION    
    windows_mesh = None
    if perform_window_detection == True:
        
        # Separate parts of the mesh, where large enough areas of low point density exist. Windows in these areas are not reliable.
        large_low_density_areas_point_cloud, large_low_density_areas_kd_tree = create_large_low_density_areas_mask(mesh_full, densities, window_detection_large_low_density_area_threshold)
        
        # Get a list of LOD2 model edges that are completely vertical. Windows close to these edges should be discarded.
        vertical_edge_list = get_mesh_vertical_edges(complete_lod2_mesh)        
        
        # DENSITY-BASED WINDOWS 
        # Use point cloud density to find potential windows (LiDAR beams that are not close to perpendicular, get reflected away, leaving a hole).
        # Use multiple threshold values to find windows both in densely and sparsely scanned areas.
        min_density_high   = density_threshold / 1.5
        min_density_normal = density_threshold / 2.5
        min_density_low    = density_threshold / 4.0
        density_based_window_bboxes = detect_windows_based_on_density(density_mesh, densities, filtered_lod2_point_cloud, min_density_high, large_low_density_areas_point_cloud, large_low_density_areas_kd_tree)
        density_based_window_bboxes += detect_windows_based_on_density(density_mesh, densities, filtered_lod2_point_cloud, min_density_normal, large_low_density_areas_point_cloud, large_low_density_areas_kd_tree)
        density_based_window_bboxes += detect_windows_based_on_density(density_mesh, densities, filtered_lod2_point_cloud, min_density_low, large_low_density_areas_point_cloud, large_low_density_areas_kd_tree)        
        # Clean up and organize density based windows
        density_based_window_bboxes = filter_density_based_windows(density_based_window_bboxes, complete_lod2_point_cloud, density_mesh, vertical_edge_list)        
        
        # SHAPE-BASED WINDOWS 
        # Use mesh shape to find potential windows (Windows often appear as pits in the mesh surface)
        shape_based_window_positions = detect_windows_based_on_shape(mesh_full, complete_lod2_point_cloud, filtered_lod2_point_cloud, large_low_density_areas_point_cloud, large_low_density_areas_kd_tree, vertical_edge_list)        
        # Clean up and organize shape based windows
        shape_based_window_bboxes = filter_shape_based_windows(shape_based_window_positions, complete_lod2_point_cloud, density_mesh )        
        
        # COMBINE WINDOWS
        windows_mesh = combine_detected_windows_into_mesh(shape_based_window_bboxes, density_based_window_bboxes, mesh_full, density_mesh)        
        
    return mesh_filtered, windows_mesh


# Utility scripts copied from Stack Overflow
def normalized(a, axis=-1, order=2):
    l2 = np.atleast_1d(np.linalg.norm(a, order, axis))
    l2[l2==0] = 1
    return a / np.expand_dims(l2, axis)
def unit_vector(vector):
    return vector / np.linalg.norm(vector)
def angle_between(v1, v2):
    """ Returns the angle in radians between vectors 'v1' and 'v2'::

            >>> angle_between((1, 0, 0), (0, 1, 0))
            1.5707963267948966
            >>> angle_between((1, 0, 0), (1, 0, 0))
            0.0
            >>> angle_between((1, 0, 0), (-1, 0, 0))
            3.141592653589793
    """
    v1_u = unit_vector(v1)
    v2_u = unit_vector(v2)
    return np.arccos(np.clip(np.dot(v1_u, v2_u), -1.0, 1.0))
def lineseg_dist(p, a, b):
    """
    Returns 3D distance from point p to a line segment [a,b]
    """
    # normalized tangent vector
    d = np.divide(b - a, np.linalg.norm(b - a))
    # signed parallel distance components
    s = np.dot(a - p, d)
    t = np.dot(p - b, d)
    # clamped parallel distance
    h = np.maximum.reduce([s, t, 0])
    # perpendicular distance component
    c = np.cross(p - a, d)
    return np.hypot(h, np.linalg.norm(c))


def create_large_low_density_areas_mask(mesh_full, densities, point_density_threshold):
    """
    Create a mask for the input mesh by first removing all high-density areas, and then also low-density areas which are too small.
    The resulting large low-density areas can be used to filter out false window detections.

    Parameters
    ----------
    mesh_full : Open3D triangle mesh
        Full Poisson mesh
    densities : Numpy.array
        Local point density for each vertex of the input mesh
    point_density_threshold : float
        The threshold used for deciding, what is low-density and what is high-density for local points.

    Returns
    -------
    large_low_density_areas_point_cloud : Open3D point cloud
        Point cloud, where each point corresponds to vertex in the input mesh, which are part of large low-density areas.
    large_low_density_areas_kd_tree : Open3D KDTree
        KDTree computed for the large low-density areas point cloud, can be used for checking if any given point is within the mask.
    """
    
    print("    clustering connected low-density triangles...")
    mesh_large_low_density_areas = copy.deepcopy(mesh_full)
    vertices_to_remove = densities > np.quantile(densities, point_density_threshold)
    mesh_large_low_density_areas.remove_vertices_by_mask(vertices_to_remove)
    mesh_large_low_density_areas = mesh_large_low_density_areas.remove_duplicated_vertices()
    mesh_large_low_density_areas = mesh_large_low_density_areas.remove_duplicated_triangles()
    mesh_large_low_density_areas = mesh_large_low_density_areas.remove_degenerate_triangles()
    #with o3d.utility.VerbosityContextManager( o3d.utility.VerbosityLevel.Debug) as cm:
    #    triangle_clusters, cluster_num_of_triangles, cluster_area = ( mesh_large_low_density_areas.cluster_connected_triangles() )
    triangle_clusters, cluster_num_of_triangles, cluster_area = ( mesh_large_low_density_areas.cluster_connected_triangles() )
    triangle_clusters        = np.asarray(triangle_clusters)   # cluster index per triangle
    cluster_num_of_triangles = np.asarray(cluster_num_of_triangles) # number of triangles per cluster
    cluster_area             = np.asarray(cluster_area)        # surface area per cluster    
    print("    gathering large low-density areas to filter out incorrect shape based detections...")
    triangles_to_remove = cluster_area[triangle_clusters] < window_detection_window_maximum_size
    mesh_large_low_density_areas.remove_triangles_by_mask(triangles_to_remove) # Removes vertex indices in the triangles only, and leaves actual vertices untouched!
    triangles = np.asarray(mesh_large_low_density_areas.triangles)
    vertices = np.asarray(mesh_large_low_density_areas.vertices)
    indices = []
    for i in range(len(triangles)):
        indices.append(triangles[i][0])
        indices.append(triangles[i][1])
        indices.append(triangles[i][2])
    # Get all vertex indices involved with the low density triangles, and create a point cloud which is used for filtering
    indices = np.unique(indices) 
    points = []
    for i in range(len(indices)):
        points.append(vertices[indices[i]])
    points = np.asarray(points)
    large_low_density_areas_point_cloud = o3d.geometry.PointCloud()
    large_low_density_areas_point_cloud.points = o3d.utility.Vector3dVector(points)
    large_low_density_areas_kd_tree = o3d.geometry.KDTreeFlann(large_low_density_areas_point_cloud)
    return large_low_density_areas_point_cloud, large_low_density_areas_kd_tree


def get_mesh_vertical_edges(complete_lod2_mesh):
    """
    Collect each vertical edge of the input mesh.
    
    Parameters
    ----------
    mesh : Open3D triangle mesh
        Input mesh to process
    
    Returns
    -------
    edge_list : List<Numpy.array>
        List of point pairs that create vertical edges in the input mesh
    """    
    triangles = np.asarray(complete_lod2_mesh.triangles)
    vertices = np.asarray(complete_lod2_mesh.vertices)
    edge_list = []
    for i in range(len(triangles)):
        vertex_0 = vertices[triangles[i][0]]
        vertex_1 = vertices[triangles[i][1]]
        vertex_2 = vertices[triangles[i][2]]
        if vertex_0[0] == vertex_1[0] and vertex_0[1] == vertex_1[1]:
            edge_list.append( [vertex_0,vertex_1] )
        if vertex_0[0] == vertex_2[0] and vertex_0[1] == vertex_2[1]:
            edge_list.append( [vertex_0, vertex_2] )
        if vertex_1[0] == vertex_2[0] and vertex_1[1] == vertex_2[1]:
            edge_list.append( [vertex_1, vertex_2] )
    return edge_list


def visualize_bboxes_on_mesh( mesh, bbox_list ):
    """
    Render mesh, and a list of bounding boxes on it
    
    Parameters
    ----------
    mesh : Open3D triangle mesh
        Base mesh to render boxes on
    bbox_list : List<Open3D oriented bounding box>
        Bounding boxes to render

    Returns
    -------
    None.

    """
    vis_boxes = copy.deepcopy(bbox_list)
    for bbox in vis_boxes:
        bbox.color = [0,0,0]
    vis_boxes.append(mesh)
    o3d.visualization.draw_geometries(vis_boxes)


def detect_windows_based_on_shape(mesh, complete_lod2_point_cloud, filtered_lod2_point_cloud, large_low_density_areas_point_cloud, large_low_density_areas_kd_tree, lod2_vertical_edge_list):
    """
    Search for windows in the input mesh by looking for small window-like indentations in the surface by using raycasting.

    Parameters
    ----------
    mesh : Open3D TriangleMesh
        Full mesh of the building combining LiDAR and LOD2 data
    complete_lod2_point_cloud : Open3D point cloud
        Full, unfiltered LOD2 point cloud
    filtered_lod2_point_cloud : Open3D point cloud
        Point cloud of LOD2 points actually used in mesh creation
    large_low_density_areas_point_cloud : Open3D point cloud
        Point cloud used as a mask to prevent window detections in low-confidence areas
    large_low_density_areas_kd_tree : Open3d KDTree
        KDTree calculated of the point cloud above
    lod2_vertical_edge_list : List<Numpy.array>
        List of vertical edges defined by two points, used to prevent window detection in building corners
        
    Returns
    -------
    window_points : List<Numpy.array>
        Intendation coordinates of probable windows in the building mesh
    """
    
    print("  detecting windows based on mesh shapes...")
    visualize_every_step = False
    
    window_points = []
    bounding_box_extents = np.empty((3,1))    
    bounding_box_extents[0] = 1
    bounding_box_extents[1] = 1
    bounding_box_extents[2] = 1
    #print("LOD2 size:", len(complete_lod2_point_cloud.points))
    #print("mesh size:", len(mesh.vertices))
    
    chosen_points = []
    points_nan = 0
    points_weird = 0 # Only appears when using radius search
    points_vertical = 0
    points_picked = 0
    points_skipped = 0
    large_low_density_area_points = np.asarray(large_low_density_areas_point_cloud.points)
    filtered_lod2_points = np.asarray(filtered_lod2_point_cloud.points)
    filtered_lod2_kd_tree = o3d.geometry.KDTreeFlann(filtered_lod2_point_cloud)
    mesh_kd_tree = o3d.geometry.KDTreeFlann(mesh)
    for vertex_num in range(len(mesh.vertices)):
        vertex = mesh.vertices[vertex_num]
        vertex_normal = mesh.vertex_normals[vertex_num]
        vertex_normal_n = normalized(vertex_normal,0)
        if(np.isnan(vertex).any()):
            # Some of the vertices can be NaN
            points_nan += 1
            points_skipped += 1
            continue
        
        # Skip vertices that are no where near a wall-like orientation (have a significant vertical component)
        if abs(vertex_normal_n[0][2]) > abs(vertex_normal_n[0][1]) or abs(vertex_normal_n[0][2]) > abs(vertex_normal_n[0][1]) or abs(vertex_normal_n[0][2]) > 0.2:
            points_vertical += 1
            points_skipped += 1
            continue
        # Skip vertices near LOD2 data that has been used in the mesh
        [k, idx, _] = filtered_lod2_kd_tree.search_knn_vector_3d(vertex, 1)
        nearest_point = filtered_lod2_points[idx][0]
        distance = np.sqrt( (vertex[0]-nearest_point[0])**2 + (vertex[1]-nearest_point[1])**2 + (vertex[2]-nearest_point[2])**2 )
        if distance < window_detection_shape_minimum_distance_to_lod2_areas:
            continue
        # Skip vertices near large low-density areas
        [k, idx, _] = large_low_density_areas_kd_tree.search_knn_vector_3d(vertex, 1)
        nearest_point = large_low_density_area_points[idx][0]
        distance = np.sqrt( (vertex[0]-nearest_point[0])**2 + (vertex[1]-nearest_point[1])**2 + (vertex[2]-nearest_point[2])**2 )
        if distance < window_detection_shape_minimum_distance_to_large_low_density_areas:
            continue
        # Filter out points that are too close to vertical LOD2 model edges (corners often have window-like shapes due to mesh imperfections)
        found_lod2_edge_too_close = False
        for j in range(len(lod2_vertical_edge_list)):
            node_1 = lod2_vertical_edge_list[j][0]
            node_2 = lod2_vertical_edge_list[j][1]
            distance = lineseg_dist(vertex, node_1, node_2)
            if distance < window_detection_shape_minimum_distance_to_lod2_vertical_edges:
                found_lod2_edge_too_close = True
                break
        if found_lod2_edge_too_close == True:
            continue
        # Check nearby vertices, and make sure at least some of them have an orientation very different from the center vertex
        angle_threshold = 30.0
        skip_vertex = True
        if window_detection_use_radius_search == True:
            [k, idx, _] = mesh_kd_tree.search_radius_vector_3d(vertex, 0.6)
            if k == 0:
                # There seem to be quite a lot of points which have no neighbors at all in range
                #print("weird point: {a}".format(a=vertex))
                points_weird += 1
                points_skipped += 1
                continue
            for i in range(len(idx)):
                neighbor_normal = mesh.vertex_normals[idx[i]]
                angle = angle_between(vertex_normal, neighbor_normal)
                if abs(math.degrees(angle)) > angle_threshold:
                    skip_vertex = False
                    break
            if skip_vertex == False:
                chosen_points.append([vertex, vertex_normal])
                points_picked += 1
            else:
                points_skipped += 1
            #print("  points picked (radius): {num1}, NaN: {num2}, weird: {num3}, vertical: {num4}, total skipped: {num5}".format(num1=points_picked, num2=points_nan, num3=points_weird, num4=points_vertical, num5=points_skipped))
        else:
            [k, idx, _] = mesh_kd_tree.search_knn_vector_3d(vertex, 10)
            if k == 0:
                print("This should only happen with radius search, output probably messed up!")
                points_weird += 1
                points_skipped += 1
                continue
            for i in range(len(idx)):
                neighbor_normal = mesh.vertex_normals[idx[i]]
                angle = angle_between(vertex_normal, neighbor_normal)
                if abs(math.degrees(angle)) > angle_threshold:
                    skip_vertex = False
                    break
            if skip_vertex == False:
                chosen_points.append([vertex, vertex_normal])
                points_picked += 1
            else:
                points_skipped += 1
        
    points = np.asarray(chosen_points)[:,0]
    normals = np.asarray(chosen_points)[:,1]
    
    if visualize_every_step == True:
        pc = o3d.geometry.PointCloud()
        pc.points = o3d.utility.Vector3dVector(points)
        o3d.visualization.draw_geometries([pc, mesh])
    
    # Investigate all the found potential window points using raycasting. If the point is a real window intendation, 2 lines perpendicular both to normal and each other should intersect the mesh twice.    
    print("  performing raycasting on chosen points (%d)..." % len(points))
    window_counter = 0
    raycast_scene = o3d.t.geometry.RaycastingScene()
    legacy_mesh = o3d.t.geometry.TriangleMesh.from_legacy(mesh)
    building_id = raycast_scene.add_triangles(legacy_mesh)
    
    vis_rays_points = []
    vis_rays_lines = []
    vis_win_points = []
    vis_win_lines = []
    
    for point_num in range(len(points)):

        point = points[point_num]
        normal = normals[point_num]
        
        # Get a point along the normal vector slightly above the point
        test_point = (point + normalized(normal,0)*window_detection_shape_depth)[0] 
        
        # Get two perpendicular lines that cross the test point, while being at right angles to each other
        ray_1 = np.array([0,0,window_detection_shape_width]) # The first ray is always vertical
        ray_2 = np.cross(normal, ray_1) # The second test ray is perpendicular to both of the other vectors
        start_point_1 = (test_point - (ray_1/2)) # Move the ray so that it tests both sides of the test point
        start_point_2 = (test_point - (ray_2/2))
        
        if visualize_every_step == True:
            # Visualize rays
            cur_index = len(vis_rays_points)
            vis_rays_points.append(start_point_1)
            vis_rays_points.append(start_point_1+ray_1)
            vis_rays_points.append(start_point_2)
            vis_rays_points.append(start_point_2+ray_2)
            vis_rays_lines.append([cur_index, cur_index+1])
            vis_rays_lines.append([cur_index+2, cur_index+3])
        
        # Perform a raycast from the test point to both directions along the two test rays. If every one of the rays hits the mesh, assume the test point being in the bottom of a window intendation
        rays = o3d.core.Tensor([[start_point_1[0], start_point_1[1], start_point_1[2], ray_1[0], ray_1[1], ray_1[2]], [start_point_2[0], start_point_2[1], start_point_2[2], ray_2[0], ray_2[1], ray_2[2]]],
                               dtype=o3d.core.Dtype.Float32)
        ans = raycast_scene.cast_rays(rays)
        #print("ans:", ans )
        if float("inf") not in ans['t_hit'].numpy(): # <-- is float("inf") caught with the distance threshold below?
            distance_threshold = 1.0
            skip_vertex = False
            for x in ans['t_hit'].numpy():
                if x > distance_threshold:
                    skip_vertex = True
                    break
        else:
            skip_vertex = True
        if skip_vertex == True:
            continue
        
        window_points.append(point)
        window_counter += 1
        
        if visualize_every_step == True:
            # Visualize detected windows
            print("Accepted window #%d" % window_counter)
            cur_index = len(vis_win_points)
            vis_win_points.append(start_point_1)
            vis_win_points.append(start_point_1+ray_1)
            vis_win_points.append(start_point_2)
            vis_win_points.append(start_point_2+ray_2)
            vis_win_lines.append([cur_index, cur_index+1])
            vis_win_lines.append([cur_index+2, cur_index+3])        

    if visualize_every_step == True:        
        print("All window candidates...")
        line_set = o3d.geometry.LineSet()
        line_set.points = o3d.utility.Vector3dVector(vis_rays_points)
        line_set.lines = o3d.utility.Vector2iVector(vis_rays_lines)
        o3d.visualization.draw_geometries([line_set, mesh])            
        print("Visualizing detected windows...")
        line_set = o3d.geometry.LineSet()
        line_set.points = o3d.utility.Vector3dVector(vis_win_points)
        line_set.lines = o3d.utility.Vector2iVector(vis_win_lines)
        o3d.visualization.draw_geometries([line_set, mesh])
    
    # NOTE: Sometimes all the shape-based windows are simply filtered away for some reason, then retained simply by re-running the algorithm. Cause unknown.
    #print("shape-based windows initially discovered:", len(window_points))
    return window_points


def filter_shape_based_windows(shape_based_window_positions, complete_lod2_point_cloud, mesh):
    """    
    Filter and combine window clusters into single objects, create bounding boxes aligned with the LOD2 data.
    
    Parameters
    ----------
    shape_based_window_positions : List<Numpy array(3,1)>
        List containing coordinates of all potential windows detected using mesh shape.
    complete_lod2_point_cloud : Open3D point cloud
        Complete unfiltered point cloud generated from LOD2 mesh. Used for rotating window bounding boxes into correct orientation.
    mesh : Open3D TriangleMesh
        Full mesh of the building.

    Returns
    -------
    adjusted_windows : List<Open3D.Geometry.OrientedBoundingBox>
        List of shape based window bounding boxes in a rotation that follows the building shape.
    """
    
    visualize_every_step = False
    
    # Filter out data points beyond height thresholds, and collapse each cluster of detections into a single window
    mesh_bbox = mesh.get_axis_aligned_bounding_box()
    min_z = mesh_bbox.min_bound[2]
    max_z = mesh_bbox.max_bound[2]
    low_height_threshold = min_z + 1 # Will filter out 1st floor if set any higher than ~1 meter. Lots of cluttered shapes and things like doorways on the first floor. Maybe ok to filter away?
    high_height_threshold = max_z - 1
    if high_height_threshold > (min_z + 35):
        high_height_threshold = min_z + 35
    
    filtered_window_positions = []
    processed = [False] * len(shape_based_window_positions)
    distance_threshold = window_detection_shape_cluster_together_distance
    for i in range(len(shape_based_window_positions)):
        if processed[i] == True:
            continue
        point_1 = shape_based_window_positions[i]
        processed[i] = True
        # Filter out points that are too low or too high
        if point_1[2] < low_height_threshold or point_1[2] > high_height_threshold:
            continue
        
        
        window_cluster = []
        window_cluster.append(point_1)
        
        # Go through all the other still unprocessed points, pick the ones that are close to the first one, and store all of them in the same list
        for j in range(len(shape_based_window_positions)):
            if processed[j] == True:
                continue            
            point_2 = shape_based_window_positions[j]
            if point_2[2] < low_height_threshold or point_2[2] > high_height_threshold:
                processed[j] = True
                continue
            dist = np.sqrt( (point_2[0]-point_1[0])**2 + (point_2[1]-point_1[1])**2 + (point_2[2]-point_1[2])**2 )
            if dist < distance_threshold:
                window_cluster.append(point_2)
                processed[j] = True
    
        # Collapse the elements in the window cluster into a single point at their average position
        window_cluster = np.asarray(window_cluster)
        avg_pos = np.average(window_cluster, axis=0)    
        filtered_window_positions.append(avg_pos)
            
    filtered_window_positions = np.asarray(filtered_window_positions)
    #print("Shape-based windows array after combining clusters:", filtered_window_positions.shape)

    # Pose and size adjustment. Create new bounding boxes for remaining windows. Use temporary size.
    adjusted_windows = []
    lod2_kd_tree = o3d.geometry.KDTreeFlann(complete_lod2_point_cloud)
    for window_number in range(len(filtered_window_positions)):        
        center = filtered_window_positions[window_number]
        bounding_box_extents = np.ones((3,1)) # Adjust size, when combining shape and density based detections
        new_bbox = o3d.geometry.OrientedBoundingBox(center, np.identity(3), bounding_box_extents)
        
        # Find the closest LOD2 point and use that point's normal vector for rotating the window to same orientation with the wall
        [k, idx, _] = lod2_kd_tree.search_knn_vector_3d(center, 1)
        nearest_normal = np.asarray(complete_lod2_point_cloud.normals)[idx][0]
        x_component = nearest_normal[0]
        y_component = nearest_normal[1]
        angle = math.tan(x_component/y_component)
        new_R = new_bbox.get_rotation_matrix_from_axis_angle([0,0,-angle])
        new_bbox.rotate(new_R)               
        new_bbox.color = [0,0,0]
        adjusted_windows.append(new_bbox)
    
    if visualize_every_step == True:
        print("filtered shape-based windows...")
        visualize_bboxes_on_mesh( mesh, adjusted_windows )
   
    return adjusted_windows




def detect_windows_based_on_density(density_mesh, densities, filtered_lod2_point_cloud, min_density, large_low_density_areas_point_cloud, large_low_density_areas_kd_tree):
    """    
    Detect windows in the input mesh based on the local point density at each vertex position.
    When a LiDAR beam hits a window in a non-perpendicular angle, it gets reflected away, creating the appearance of a hole in the mesh.
    
    Parameters
    ----------
    density_mesh : Open3D TriangleMesh
        Full mesh of the building, color-coded with point densities.
    densities : Numpy.array(N,3)
        Local point density (combined LiDAR and LOD2 points) of each vertex of the input mesh.
    filtered_lod2_point_cloud : Open3D point cloud
        Points in the input mesh that originate from LOD2 data. 
        Used to filter out detected windows in those regions, since LOD2 model does not contain window holes, but there is a gap between LOD2 and LiDAR data.
    min_density : float
        Threshold density for filtering windows from the input mesh
    large_low_density_areas_kd_tree : Open3d KDTree
        KDTree calculated of the point cloud above
    lod2_vertical_edge_list : List<Numpy.array>
        List of vertical edges defined by two points, used to prevent window detection in building corners

    Returns
    -------
    oriented_bounding_boxes : Open3D.Geometry.OrientedBoundingBox
        Bounding boxes for the detected windows. In very random rotations and in various sizes.
    """
    
    visualize_every_step = False
    
    # Remove high-density areas, leaving isolated low-density zones. The small objects near the LOD2 shell are probably windows.
    print("   removing high-density areas...")
    mesh_low_density = copy.deepcopy(density_mesh)
    vertices_to_remove = densities > np.quantile(densities, min_density)
    mesh_low_density.remove_vertices_by_mask(vertices_to_remove)
    mesh_low_density = mesh_low_density.remove_duplicated_vertices()
    mesh_low_density = mesh_low_density.remove_duplicated_triangles()
    mesh_low_density = mesh_low_density.remove_degenerate_triangles()

    print("    clustering connected triangles (1st iteration)...")
    triangle_clusters, cluster_num_of_triangles, cluster_area = ( mesh_low_density.cluster_connected_triangles() )
    triangle_clusters        = np.asarray(triangle_clusters)   # cluster index per triangle
    cluster_num_of_triangles = np.asarray(cluster_num_of_triangles) # number of triangles per cluster
    cluster_area             = np.asarray(cluster_area)        # surface area per cluster
   
    print("   filtering out non-window-sized objects...")
    triangles_to_remove = ( cluster_area[triangle_clusters] > window_detection_window_maximum_size )
    mesh_low_density.remove_triangles_by_mask(triangles_to_remove)
    if visualize_every_step == True:
        o3d.visualization.draw_geometries([mesh_low_density])
    
    print("   clustering connected triangles (2nd iteration)...")
    triangle_clusters, cluster_num_of_triangles, cluster_area = ( mesh_low_density.cluster_connected_triangles() )
    triangle_clusters        = np.asarray(triangle_clusters)   # cluster index per triangle
    cluster_num_of_triangles = np.asarray(cluster_num_of_triangles) # number of triangles per cluster
    cluster_area             = np.asarray(cluster_area)        # surface area per cluster

    print("   setting up bounding boxes for each cluster, and removing potential windows that are too close to LOD2 data...")
    all_vertices  = np.asarray(mesh_low_density.vertices)
    num_clusters  = len(cluster_num_of_triangles)
    num_triangles = len(triangle_clusters)
    oriented_bounding_boxes = []    
  
    lod2_kd_tree = o3d.geometry.KDTreeFlann(filtered_lod2_point_cloud) # Used for filtering windows that are near or on LOD2 data that's used in the final point cloud
    for cluster_num in range(num_clusters):    
        tmp_mesh = copy.deepcopy(mesh_low_density)
        triangles_to_remove = triangle_clusters != cluster_num
        tmp_mesh.remove_triangles_by_mask(triangles_to_remove) # Removes triangles from the mesh (removes references to vertex indices, but keeps all vertices!)
        new_triangles = np.asarray(tmp_mesh.triangles)
        num_triangles = len(new_triangles)
        if num_triangles < 3:
            continue
        cluster_point_indices = set()
        cluster_too_close_to_lod2 = False
        cluster_too_close_to_large_low_density_area = False
        for triangle_num in range(num_triangles):
            index_1 = new_triangles[triangle_num][0]
            index_2 = new_triangles[triangle_num][1]
            index_3 = new_triangles[triangle_num][2]
            
            # See if the triangle is too close to LOD2 data (filtered) to be accepted. Triangles are small, so just test one of the points to save time.
            point = all_vertices[index_1]            
            [k, idx, _] = lod2_kd_tree.search_knn_vector_3d(point, 1)
            nearest_point = np.asarray(filtered_lod2_point_cloud.points)[idx][0]
            distance = np.sqrt( (point[0]-nearest_point[0])**2 + (point[1]-nearest_point[1])**2 + (point[2]-nearest_point[2])**2 )
            if distance < window_detection_density_minimum_distance_to_lod2_areas:
                cluster_too_close_to_lod2 = True
                break
            
            # See also, if the triangle is too close to a large low-density area, where detections cannot be trusted
            [k, idx, _] = large_low_density_areas_kd_tree.search_knn_vector_3d(point, 1)
            nearest_point = np.asarray(large_low_density_areas_point_cloud.points)[idx][0]
            distance = np.sqrt( (point[0]-nearest_point[0])**2 + (point[1]-nearest_point[1])**2 + (point[2]-nearest_point[2])**2 )
            if distance < window_detection_density_minimum_distance_to_large_low_density_areas:
                cluster_too_close_to_large_low_density_area = True
                break
            
            cluster_point_indices.add(index_1)
            cluster_point_indices.add(index_2)
            cluster_point_indices.add(index_3)
        if cluster_too_close_to_lod2 == True or cluster_too_close_to_large_low_density_area == True:
            continue
        index_array = np.array(list(cluster_point_indices))
        cluster_points = all_vertices[index_array]
         
        # NOTE: Combining mobile LiDAR scans, there's generally enough noise to use the accurate non-robust version of the bounding box creation algorithm, 
        #       but with better scans, the triangle cluster points are often co-planar.
        OBBox = o3d.geometry.OrientedBoundingBox.create_from_points(o3d.utility.Vector3dVector(cluster_points), robust=True)
        oriented_bounding_boxes.append(OBBox)
    
    return oriented_bounding_boxes




def filter_density_based_windows(potential_density_based_windows, complete_lod2_point_cloud, mesh, lod2_vertical_edge_list):
    """
    Combine detected window clusters into single objects, and rotate all window bounding boxes, so that they are standing upright and follow the wall rotation, also making them evenly sized.
    
    Parameters
    ----------
    potential_density_based_windows : List<Open3D.Geometry.OrientedBoundingBox>
        Bounding boxes of all density based windows detected. Need to be filtered and positioned.
    shape_based_windows : List<Open3D.Geometry.OrientedBoundingBox>
        List containing oriented bounding boxes of all potential windows detected using mesh shape, already filtered.
    complete_lod2_point_cloud : Open3D point cloud
        Complete unfiltered point cloud generated from LOD2 mesh. Used for rotating window bounding boxes into correct orientation.
    mesh : Open3D TriangleMesh
        Full mesh of the building.

    Returns
    -------
    oriented_bounding_boxes : List<Open3D.Geometry.OrientedBoundingBox>
        List of density based window bounding boxes organized into neat rows and columns, in a rotation that follows the building shape.
    """
    
    visualize_every_step = False    
    windows = []
    
    mesh_bbox = mesh.get_axis_aligned_bounding_box()
    min_z = mesh_bbox.min_bound[2]
    max_z = mesh_bbox.max_bound[2]
    low_height_threshold = min_z + 1
    high_height_threshold = max_z - 1
    if high_height_threshold > (min_z + 35):
        high_height_threshold = min_z + 35
    #low_volume_threshold = 0.0 # Set to zero to have no minimum volume
    #high_volume_threshold = 2.0
    
    max_bb_extents = []
    
    print("Density based windows before filtering: {num}".format(num=len(potential_density_based_windows)))
    if visualize_every_step == True:
        print("Visualizing potential density based windows before any filtering...")
        visualize_bboxes_on_mesh( mesh, potential_density_based_windows )

    
    # Compute a KDTree for the mesh that is used for checking window position normals
    if mesh.has_vertex_normals() == False:
        mesh.compute_vertex_normals()
    points = np.asarray(mesh.vertices)
    mesh_point_cloud = o3d.geometry.PointCloud()
    mesh_point_cloud.points = o3d.utility.Vector3dVector(points)
    mesh_kd_tree = o3d.geometry.KDTreeFlann(mesh_point_cloud)
    

    # First round of filtering - eliminations
    filtered_window_positions = []
    processed = [False] * len(potential_density_based_windows)
    for bb_number_1 in range(len(potential_density_based_windows)):
        if processed[bb_number_1] == True:
            continue
        bbox_1 = potential_density_based_windows[bb_number_1]
        center_1 = bbox_1.center
        processed[bb_number_1] = True

        # Discard points that are too close to LOD2 model vertical edges
        found_lod2_edge_too_close = False
        for j in range(len(lod2_vertical_edge_list)):
            node_1 = lod2_vertical_edge_list[j][0]
            node_2 = lod2_vertical_edge_list[j][1]
            distance = lineseg_dist(center_1, node_1, node_2)
            if distance < 0.5:
                found_lod2_edge_too_close = True
                break
        if found_lod2_edge_too_close == True:
            continue
 
        # Volume is already kinda filtered earlier, when triangles are clustered during detection and filtered by cluster area
        if center_1[2] < low_height_threshold or center_1[2] > high_height_threshold:
            continue
        
        # Combine windows that are close to each other into a single bounding box, and move it to the average position of all the combined windows
        cluster = []
        cluster.append(bbox_1)
        max_bb_extents.append(max(bbox_1.extent))
        for bb_number_2 in range(len(potential_density_based_windows)):
            if processed[bb_number_2] == True:
                continue
            bbox_2 = potential_density_based_windows[bb_number_2]
            center_2 = bbox_2.center
            if center_2[2] < low_height_threshold or center_2[2] > high_height_threshold:
                processed[bb_number_2] = True
                continue            
            distance = np.sqrt( (center_2[0]-center_1[0])**2 + (center_2[1]-center_1[1])**2 + (center_2[2]-center_1[2])**2 )
            if distance < window_detection_density_cluster_together_distance:
                cluster.append(bbox_2)
                max_bb_extents.append(max(bbox_2.extent))
                processed[bb_number_2] = True
        centers = []
        for i in range(len(cluster)):
            bbox = cluster[i]
            centers.append(bbox.center)
        average_position = np.mean(np.asarray(centers), axis=0)
        filtered_window_positions.append(average_position)
    
    if len(filtered_window_positions) == 0:
        return windows
    
    average_window_size = np.mean(max_bb_extents)
    print("Average size of a window in max dimension:", average_window_size)


    # Second round of filtering - pose and size adjustment. Create new bounding boxes for remaining windows in correct poses using the average max dimension size of all detected windows
    adjusted_windows = []
    bounding_box_extents = np.empty((3,1))    
    bounding_box_extents[0] = average_window_size
    bounding_box_extents[1] = average_window_size
    bounding_box_extents[2] = average_window_size
    lod2_kd_tree = o3d.geometry.KDTreeFlann(complete_lod2_point_cloud)
    for window_number in range(len(filtered_window_positions)):
        
        center = filtered_window_positions[window_number]

        # Check the normal vector of the nearest vertex to the window position. If it is not near-horizontal, skip the window
        [k, idx, _] = mesh_kd_tree.search_knn_vector_3d(center, 1)
        nearest_normal = np.asarray(mesh.vertex_normals)[idx][0]
        if abs(nearest_normal[2]) > (abs(nearest_normal[0]) + abs(nearest_normal[1])):
            continue
                
        # Window is accepted. Create and set a bounding box for it
        new_bbox = o3d.geometry.OrientedBoundingBox(center, np.identity(3), bounding_box_extents)
        
        # Find the closest LOD2 point and use that point's normal vector for rotating the window to same orientation with the wall
        [k, idx, _] = lod2_kd_tree.search_knn_vector_3d(center, 1)
        nearest_normal = np.asarray(complete_lod2_point_cloud.normals)[idx][0]
        x_component = nearest_normal[0]
        y_component = nearest_normal[1]
        angle = math.tan(x_component/y_component)
        new_R = new_bbox.get_rotation_matrix_from_axis_angle([0,0,-angle])
        new_bbox.rotate(new_R)                
        adjusted_windows.append(new_bbox)

    if visualize_every_step == True:
        print("Density based windows after second round of filtering: {num}".format(num=len(adjusted_windows)))
        visualize_bboxes_on_mesh( mesh, adjusted_windows )
            
    return adjusted_windows

    

def combine_detected_windows_into_mesh(shape_based_window_bboxes, density_based_window_bboxes, mesh, density_mesh):
    """
    Combine windows detected by different means, and arrange them into neat columns and rows, filtering out extra ones.
    
    Parameters
    ----------
    density_based_window_bboxes : List<Open3D oriented bounding box>
        Bounding boxes of all density based windows detected. 
    shape_based_window_bboxes : List<Open3D oriented bounding box>
        List containing oriented bounding boxes of all potential windows detected using mesh shape.
    mesh : Open3D TriangleMesh
        Full mesh of the building.
    density_mesh : Open3D TriangleMesh
        Full mesh of the building, colored to visualize point density.

    Returns
    -------
    windows_mesh : Open3D triangle mesh
        Mesh with all detected windows, presented as bounding box cubes (cube size does not represent actual window size)
    """
        
    
    visualize_every_step = False
        
    print("Adding both window types together without filtering...")
    combined_windows = shape_based_window_bboxes + density_based_window_bboxes
    if visualize_every_step == True:
        print("Density based windows before combining...")
        visualize_bboxes_on_mesh( density_mesh, density_based_window_bboxes )
        print("Shape based windows before combining...")
        visualize_bboxes_on_mesh( mesh, shape_based_window_bboxes )
    
    # Combine windows that are too close to each other
    windows = []
    cluster = []
    processed = [False] * len(combined_windows)
    distance_threshold = 0.4
    while True:
        if len(cluster) == 0:
            # Set the first unprocessed bounding box as the first element of the cluster
            for bb_number in range(len(combined_windows)):
                if processed[bb_number] == True:
                    continue
                cluster.append(bb_number)
                processed[bb_number] = True
                break
        if len(cluster) == 0:
            break
        # Loop the windows until no new data is gathered
        found_new_data = False
        for bb_number_1 in range(len(cluster)):
            bbox_1 = combined_windows[cluster[bb_number_1]]
            center_1 = bbox_1.center
            for bb_number_2 in range(len(combined_windows)):
                if processed[bb_number_2] == True:
                    continue
                bbox_2 = combined_windows[bb_number_2]
                center_2 = bbox_2.center
                distance = np.sqrt( (center_2[0]-center_1[0])**2 + (center_2[1]-center_1[1])**2 + (center_2[2]-center_1[2])**2 )
                if distance < distance_threshold:
                    cluster.append(bb_number_2)
                    processed[bb_number_2] = True
                    found_new_data = True
                    break
            if found_new_data == True:
                break
        
        if found_new_data == False:
            print("Cluster:", cluster)
            # No new data could be connected to this cluster anymore. Combine.
            centers = [combined_windows[i].center for i in cluster]
            #median = np.median(centers, axis=0)
            average = np.average(centers, axis=0)
            combined_bbox = combined_windows[cluster[0]]
            combined_bbox.center = average
            windows.append(combined_bbox)
            cluster = []
            
            
    # Horizontal position adjustment/filtering
    # Compare bounding box position to all the others, and collect indices of the ones roughly in the same column. 
    distance_threshold = 0.5
    processed = [False] * len(windows)
    cluster = []
    paired_indices = []
    print("ordering to rows. Number of windows:", len(windows))
    while True:
        if len(cluster) == 0:
            # Set the first unprocessed bounding box as the first element of the cluster
            for bb_number in range(len(windows)):
                if processed[bb_number] == True:
                    continue
                cluster.append(bb_number)
                print("add bbox #{num}".format(num=bb_number))
                processed[bb_number] = True
                break
        if len(cluster) == 0:
            break
        # Loop the windows until no new data is gathered
        found_new_data = False
        for bb_number_1 in range(len(cluster)):
            bbox_1 = windows[cluster[bb_number_1]]
            center_1 = bbox_1.center
            for bb_number_2 in range(len(windows)):
                if processed[bb_number_2] == True:
                    continue
                bbox_2 = windows[bb_number_2]
                center_2 = bbox_2.center
                distance_vertical = abs( center_2[2]-center_1[2])
                if distance_vertical < distance_threshold:
                    cluster.append(bb_number_2)
                    #print("add bbox #{num}".format(num=bb_number_2))
                    processed[bb_number_2] = True
                    found_new_data = True
                    break
            if found_new_data == True:
                break
        
        if found_new_data == False:
            # No new data could be connected to this cluster anymore. Shift all the collected bounding boxes to the same column at the horizontal median point of all of them
            centers = [windows[i].center for i in cluster]
            #median = np.median(centers, axis=0)
            average = np.average(centers, axis=0)
            print("finished cluster:", cluster)
            if len(cluster) > 1:
                for i in range(len(cluster)):
                    paired_indices.append(cluster[i])
            for i in range(len(windows)):
                if i in cluster:
                    center = copy.deepcopy(windows[i].center)
                    center[2] = average[2]
                    windows[i].center = center
            cluster = []
    
    if visualize_every_step == True:
        print("After horizontal positioning...")
        visualize_bboxes_on_mesh( mesh, windows )

    """
    # Remove the windows which could not be paired horizontally
    unpaired_indices = []
    for i in range(len(windows)):
        if i not in paired_indices:
            unpaired_indices.append(i)    
    unpaired_indices = sorted(unpaired_indices, reverse=True)
    #unpaired_indices = np.unique(unpaired_indices)
    print("Removing indices:", unpaired_indices)
    for idx in unpaired_indices:
        if idx < len(windows):
            print("  removing #%d" % idx)
            windows.pop(idx)
        
    if visualize_every_step == True:
        print("After deleting unpaired...")
        visualize_bboxes_on_mesh( mesh, windows ) 
    """

    # Vertical position adjustment/filtering
    # Compare bounding box position to all the others, and collect indices of the ones roughly in the same column. 
    distance_threshold = 0.5
    processed = [False] * len(windows)
    cluster = []
    print("ordering to columns. Number of windows:", len(windows))
    while True:
        if len(cluster) == 0:
            # Set the first unprocessed bounding box as the first element of the cluster
            for bb_number in range(len(windows)):
                if processed[bb_number] == True:
                    continue
                cluster.append(bb_number)
                print("add bbox #{num}".format(num=bb_number))
                processed[bb_number] = True
                break
        if len(cluster) == 0:
            break
        # Loop the windows until no new data is gathered
        found_new_data = False
        for bb_number_1 in range(len(cluster)):
            bbox_1 = windows[cluster[bb_number_1]]
            center_1 = bbox_1.center
            for bb_number_2 in range(len(windows)):
                if processed[bb_number_2] == True:
                    continue
                bbox_2 = windows[bb_number_2]
                center_2 = bbox_2.center
                distance_horizontal = np.sqrt( (center_2[0]-center_1[0])**2 + (center_2[1]-center_1[1])**2 )
                if distance_horizontal < distance_threshold:
                    cluster.append(bb_number_2)
                    #print("add bbox #{num}".format(num=bb_number_2))
                    processed[bb_number_2] = True
                    found_new_data = True
                    break
            if found_new_data == True:
                break
        
        if found_new_data == False:
            # No new data could be connected to this cluster anymore. Shift all the collected bounding boxes to the same column at the horizontal median point of all of them
            centers = [windows[i].center for i in cluster]
            median = np.median(centers, axis=0)
            #average = np.average(centers, axis=0)
            print("finished cluster:", cluster)
            if len(cluster) > 1:
                for i in range(len(cluster)):
                    paired_indices.append(cluster[i])
            for i in range(len(windows)):
                if i in cluster:
                    center = copy.deepcopy(windows[i].center)
                    center[0] = median[0]
                    center[1] = median[1]
                    windows[i].center = center
            cluster = []
            
    if visualize_every_step == True:
        print("After vertical positioning...")
        visualize_bboxes_on_mesh( mesh, windows )
    
    # Remove the windows which could not be paired vertically or horizontally
    unpaired_indices = []
    for i in range(len(windows)):
        if i not in paired_indices:
            unpaired_indices.append(i)    
    unpaired_indices = sorted(unpaired_indices, reverse=True)
    #unpaired_indices = np.unique(unpaired_indices)
    print("Removing indices:", unpaired_indices)
    for idx in unpaired_indices:
        if idx < len(windows):
            windows.pop(idx)
               
    if visualize_every_step == True:
        print("After deleting unpaired...")
        visualize_bboxes_on_mesh( mesh, windows )
    
       
    # Create a new combined mesh of all the windows
    window_vertices = []
    window_triangles = []
    print("  generating meshes for detected windows...")
    for i in range(len(windows)):
        vertices = windows[i].get_box_points()
        triangles = [ [3,6,5],[5,6,4],  [0,3,5],[0,5,2],  [1,0,2],[1,2,7],  [6,1,4],[4,1,7],  [5,4,2],[2,4,7],  [0,1,3],[3,1,6] ]
        offset = i*8
        triangles = [[v+offset for v in tri] for tri in triangles]
        window_vertices += vertices
        window_triangles += triangles
    window_vertices = o3d.utility.Vector3dVector(window_vertices)
    window_triangles = o3d.utility.Vector3iVector(window_triangles)
    windows_mesh = o3d.geometry.TriangleMesh( vertices=window_vertices, triangles=window_triangles )
    windows_mesh.compute_vertex_normals()
    if visualize_every_step == True:
        print("Final combined window meshes...")
        o3d.visualization.draw_geometries([windows_mesh, mesh])
    
    return windows_mesh



def main():
    global input_point_cloud_filename
    global input_lod2_obj_filename
    global combined_point_cloud_filename
    global output_mesh_filename
    output_windows_mesh_filename = None
    
    print("\n\n")
    start_time = time.time()
    combined_point_cloud = None
    complete_lod2_point_cloud = None
    filtered_lod2_point_cloud = None
    complete_lod2_mesh = None

    if process_entire_directory == True:
        # Process every file in input directory
        for root, dirs, files in os.walk( input_point_cloud_path ):
            for filename in files:
                if filename.endswith(".las"):
                    print("Processing point cloud:", filename)
                    input_point_cloud_filename    = os.path.join( input_point_cloud_path, filename )
                    input_lod2_obj_filename       = filename[0:-11] + ".obj"
                    input_lod2_obj_filename       = os.path.join( input_lod2_obj_path, input_lod2_obj_filename )
                    combined_point_cloud_filename = filename[0:-4] + "_combined.ply"
                    combined_point_cloud_filename = os.path.join( output_point_cloud_path, combined_point_cloud_filename )
                    output_mesh_filename          = filename[0:-4] + ".ply"
                    output_windows_mesh_filename  = "windows_" + output_mesh_filename
                    output_mesh_filename          = os.path.join( output_mesh_path, output_mesh_filename )
                    if os.path.exists(output_mesh_filename) == True:
                        print("  output files already exist. Skipping this building...")
                        continue
                    
                    # Load data
                    combined_point_cloud = None
                    if use_preprocessed_data == True:
                        print("  Loading preprocessed data...")
                        combined_point_cloud = load_point_cloud(combined_point_cloud_filename)
                    else:
                        print("  Input LOD2 object:", input_lod2_obj_filename)
                        print("  Loading data...")
                        # Get the LiDAR point cloud
                        lidar_point_cloud = load_point_cloud(input_point_cloud_filename)
                        # Convert LOD2 mesh into a point cloud
                        complete_lod2_point_cloud, complete_lod2_mesh = convert_obj_to_point_cloud(input_lod2_obj_filename)    
                        # Compare point clouds and filter the LOD2 data
                        print("  Processing data: %d LiDAR points and %d LOD2 points..." % (len(lidar_point_cloud.points), len(complete_lod2_point_cloud.points) ) )
                        filtered_lod2_point_cloud, filtered_lidar_point_cloud = filter_point_clouds( complete_lod2_point_cloud, lidar_point_cloud )
                    
                        # Combine the two point clouds
                        print("  Combining the point clouds...")
                        lidar_points = np.asarray( filtered_lidar_point_cloud.points )
                        lidar_normals = np.asarray( filtered_lidar_point_cloud.normals )
                        lod2_points = np.asarray( filtered_lod2_point_cloud.points )
                        lod2_normals = np.asarray( filtered_lod2_point_cloud.normals )
                        combined_points = np.concatenate((lidar_points, lod2_points), axis=0)
                        combined_normals = np.concatenate((lidar_normals, lod2_normals), axis=0)
                        
                        mms_ids = np.ones((len(lidar_points),1))
                        lod2_ids = np.zeros((len(lod2_points),1))
                        point_cloud_ids = np.concatenate((mms_ids, lod2_ids), axis=0)
                        
                        combined_point_cloud = o3d.geometry.PointCloud()
                        combined_point_cloud.points = o3d.utility.Vector3dVector(combined_points)
                        combined_point_cloud.normals = o3d.utility.Vector3dVector(combined_normals)

                        print("  Writing output point cloud:", combined_point_cloud_filename)
                        if combined_point_cloud_filename.endswith(".las"):
                            write_las(combined_point_cloud_filename, combined_point_cloud, point_cloud_ids)
                        else:
                            o3d.io.write_point_cloud(combined_point_cloud_filename, combined_point_cloud, write_ascii=False, compressed=False, print_progress=True)
                    
                    if create_meshes == True:
                        # Create mesh from the combined data
                        print("  Writing output mesh:", output_mesh_filename)
                        mesh, windows_mesh = create_mesh(combined_point_cloud, filtered_lod2_point_cloud, complete_lod2_point_cloud)
                        o3d.io.write_triangle_mesh(output_mesh_filename, mesh)
                        if perform_window_detection == True:
                            output_windows_mesh_filename = "windows_" + output_mesh_filename
                            o3d.io.write_triangle_mesh(output_windows_mesh_filename, windows_mesh)

                    
    else:
        # Process a single building
        combined_point_cloud = None
        if use_preprocessed_data == True:
            print("Loading preprocessed data...")
            print("  Combined point cloud:", combined_point_cloud_filename)
            combined_point_cloud_file                         = os.path.join( output_point_cloud_path, combined_point_cloud_filename )
            combined_point_cloud                              = load_point_cloud( combined_point_cloud_file )
            print("  Loaded data: %d combined points" % len(combined_point_cloud.points) )
            if perform_window_detection == True:
                output_windows_mesh_filename                  = "windows_" + output_mesh_filename
                output_windows_mesh_filename                  = os.path.join( output_mesh_path, output_windows_mesh_filename )
                lod2_file                                     = os.path.join( input_lod2_obj_path, input_lod2_obj_filename )
                complete_lod2_point_cloud, complete_lod2_mesh = convert_obj_to_point_cloud( lod2_file )    
            if create_meshes == True:
                output_mesh_filename                          = os.path.join( output_mesh_path, output_mesh_filename )
        else:
            print("Processing point cloud:", input_point_cloud_filename)
            print("  Input LOD2 object:", input_lod2_obj_filename)
            print("  Loading data...")
            # Get the LiDAR point cloud
            lidar_filename                                    = os.path.join( input_point_cloud_path, input_point_cloud_filename )
            lidar_point_cloud                                 = load_point_cloud( lidar_filename )
            # Convert LOD2 mesh into a point cloud
            lod2_filename                                     = os.path.join( input_lod2_obj_path, input_lod2_obj_filename )
            complete_lod2_point_cloud, complete_lod2_mesh     = convert_obj_to_point_cloud( lod2_filename )
            if perform_window_detection == True:
                output_windows_mesh_filename                  = "windows_" + output_mesh_filename
                output_windows_mesh_filename                  = os.path.join( output_mesh_path, output_windows_mesh_filename )
            if create_meshes == True:
                output_mesh_filename                          = os.path.join( output_mesh_path, output_mesh_filename )
            
            # Compare point clouds and filter the LOD2 data
            print("  Processing data: %d LiDAR points and %d LOD2 points..." % (len(lidar_point_cloud.points), len(complete_lod2_point_cloud.points) ) )
            filtered_lod2_point_cloud, filtered_lidar_point_cloud = filter_point_clouds( complete_lod2_point_cloud, lidar_point_cloud )
            
            # Combine the two point clouds
            if skip_lod2_on_mesh_creation == True:
                print("  Not using LOD2 data for mesh creation!")
                combined_point_cloud = filtered_lidar_point_cloud
                combined_point_cloud = filter_noise(combined_point_cloud, 0.3, 2)
            else:
                print("  Combining the point clouds...")
                filtered_lidar_point_cloud = filter_noise(filtered_lidar_point_cloud, 1.0, 12)
                lidar_points = np.asarray( filtered_lidar_point_cloud.points )
                lidar_normals = np.asarray( filtered_lidar_point_cloud.normals )
                lod2_points = np.asarray( filtered_lod2_point_cloud.points )
                lod2_normals = np.asarray( filtered_lod2_point_cloud.normals )
                combined_points = np.concatenate((lidar_points, lod2_points), axis=0)
                
                mms_ids = np.ones((len(lidar_points),1))
                lod2_ids = np.zeros((len(lod2_points),1))
                point_cloud_ids = np.concatenate((mms_ids, lod2_ids), axis=0)
                print("Point count:", len(combined_points))
                print("id count:", len(point_cloud_ids))
                
                print("Recovered point cloud IDs:", np.unique(point_cloud_ids))
                combined_normals = np.concatenate((lidar_normals, lod2_normals), axis=0)
                combined_point_cloud = o3d.geometry.PointCloud()
                combined_point_cloud.points = o3d.utility.Vector3dVector(combined_points)                
                combined_point_cloud.normals = o3d.utility.Vector3dVector(combined_normals)

            print("  Writing combined point cloud:", combined_point_cloud_filename)
            complete_output_filename = os.path.join( output_point_cloud_path, combined_point_cloud_filename )
            if complete_output_filename.endswith(".las"):
                write_las(complete_output_filename, combined_point_cloud, point_cloud_ids)
            else:
                o3d.io.write_point_cloud(complete_output_filename, combined_point_cloud, write_ascii=False, compressed=False, print_progress=True)
            
        if create_meshes == True:
            # Create mesh from the combined data        
            mesh, windows_mesh = create_mesh(combined_point_cloud, filtered_lod2_point_cloud, complete_lod2_point_cloud, complete_lod2_mesh)
            print("  Writing output mesh:", output_mesh_filename)
            o3d.io.write_triangle_mesh(output_mesh_filename, mesh)
            if perform_window_detection == True:
                o3d.io.write_triangle_mesh(output_windows_mesh_filename, windows_mesh)
        
    elapsed_time = time.time() - start_time
    print("All done. Elapsed time: {num} seconds".format(num=elapsed_time))
    
    

def create_mesh(combined_point_cloud, filtered_lod2_point_cloud, complete_lod2_point_cloud, complete_lod2_mesh):
    """
    Create a mesh of the input point cloud using Poisson Surface Reconstruction algorithm, and then process the mesh to clean it and detect windows.
    
    Parameters
    ----------
    combined_point_cloud : Open3D point cloud
        Point cloud to give the Poisson algorithm as input
    filtered_lod2_point_cloud : Open3D point cloud
        LOD2 points used in the mesh generation, used for window detection.
    complete_lod2_point_cloud : Open3D point cloud
        The complete LOD2 point cloud, regardless of if its points are used in the mesh. Used for window detection.
    complete_lod2_mesh : Open3D triangle mesh
        Used for window detection.

    Returns
    -------
    mesh : Open3D triangle mesh
        The output Poisson mesh
    windows_mesh : Open3D triangle mesh
        The output windows mesh
    """
    print("  Creating mesh...")
    mesh, densities = perform_poisson_surface_reconstruction( combined_point_cloud, mesh_creation_depth, mesh_creation_n_threads )
    print("Initial mesh vertex count:", len(np.asarray(mesh.vertices)))
    print("Densities:", np.asarray(densities).shape)
    print("  Processing mesh...")
    mesh, windows_mesh = process_mesh(mesh, densities, filtered_lod2_point_cloud, complete_lod2_point_cloud, complete_lod2_mesh)
    return mesh, windows_mesh 


def write_las(filename, point_cloud, point_cloud_ids = None):
    
    points = np.asarray(point_cloud.points)
    
    header = laspy.LasHeader(point_format=3, version="1.4")
    header.scale = [0.001, 0.001, 0.001]
    las = laspy.LasData(header)
    all_x = points[:,0]
    all_y = points[:,1]
    all_z = points[:,2]
    las.x = all_x
    las.y = all_y
    las.z = all_z
    if point_cloud_ids is not None:
        point_cloud_ids = np.reshape(point_cloud_ids, (-1))
        las.user_data = point_cloud_ids
    las.write(filename)
    
    
if __name__ == '__main__':
    main()
